---
description: 
globs: 
alwaysApply: true
---
# Next.js 15 Turbo Monorepo Architecture

## Project Overview
This is a modern Next.js 15 monorepo using Turborepo with multiple apps sharing common packages for maximum code reuse and maintainability.

## Framework & Core Technologies
- **Next.js 15**: App Router, Server Components, Server Actions
- **React 19**: Server Components, Hooks (including useOptimistic)
- **TypeScript**: Strict type checking
- **Turborepo**: Monorepo management

## Package Management
- **Primary Tool**: pnpm
- **Installation Pattern**: Always install packages in their respective app directories
  ```bash
  # Example: Installing a package in the web app
  cd apps/web
  pnpm add <package-name>
  
  # Example: Adding a dev dependency
  pnpm add -D <package-name>
  ```

## File Structure
```
apps/
├── admin/ - Admin dashboard interface
├── api/ - API routes and endpoints
├── email/ - Email templates and preview
├── studio/ - Content management
└── web/ - Main user-facing application

packages/
├── ai/ - Vercel AI SDK integration
├── analytics/ - PostHog analytics
├── auth/ - Clerk authentication
├── cookie/ - Cookie consent management
├── database/ - Prisma schema and client
├── design-system/ - UI components and styling
├── email/ - React Email and Resend
├── next-config/ - Shared Next.js configurations
├── observability/ - Better Stack monitoring
├── payments/ - Stripe payment integration
├── rate-limit/ - Rate limiting implementation
├── security/ - Arcjet security features
├── seo/ - Shared metadata components
├── storage/ - Vercel Blob Storage integration
├── testing/ - Vitest testing utilities
└── webhooks/ - Webhook handlers
```

## Component Development Guidelines
- Create new components in appropriate app directory (e.g., `apps/web/components/`)
- Use hyphenated lowercase for component file naming
- Maximum file size: 300 lines (refactor larger files)
- Prefer Server Components unless client interactivity is needed
- Extract client-side logic to separate Client Components
- Implement loading states for optimal UX
- Test all components thoroughly

## Styling Standards
- **Primary**: Tailwind CSS 4 
- **Component Library**: shadcn/ui
- **Location**: All styling centralized in `packages/design-system`
- **Themes**: Support both light and dark modes
- **Consistency**: Follow established design patterns

## Data Management
- **ORM**: Prisma
- **Location**: All database code in `packages/database`
- **Actions**: Server-side mutations via Next.js Server Actions in `apps/web/actions/`
- **Optimistic Updates**: Use React 19's `useOptimistic` for smooth UX

## Authentication & Security
- **Provider**: Clerk (UI components + functionality)
- **Security**: Implement Arcjet for additional protections
- **Rate Limiting**: Use built-in rate limiting for API routes

## Testing Strategy
- **Framework**: Vitest
- **Approach**: Test-driven development (TDD)
- **Pattern**: Write failing tests → Implement code → Ensure tests pass
- **Coverage**: Aim for high test coverage of critical paths

## Best Practices
- Plan thoroughly before implementation
- Break complex tasks into smaller, testable units
- Reuse existing code whenever possible
- Maintain clean, consistent naming conventions
- Optimize for performance and UX
- Document code thoroughly
- Follow accessibility standards

