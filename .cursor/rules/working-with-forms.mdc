---
description: Handles forms in components - creating and managing
globs: 
alwaysApply: false
---
# Form Handling in Next.js 15

This guide outlines the best practices for implementing forms in our Next.js 15 application. Forms are implemented using React Hook Form, Zod validation, and Next.js Server Actions.

## Architecture Overview

Our form implementation follows a 3-layer architecture:

1. **Schema Layer**: Zod validation schemas in `apps/web/schemas/{form-name}.schema.ts`
2. **Action Layer**: Server actions in `apps/web/actions/{feature}/{form-name}.action.ts`
3. **UI Layer**: Client components in `apps/web/components/{feature}-components/{form-name}-form.tsx`

## 1. Schema Layer

Always define a Zod schema for form validation:

```ts
// apps/web/schemas/example-form.schema.ts
import { z } from "zod";

export const exampleFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: "Name must be at least 2 characters" })
    .max(50, { message: "Name cannot exceed 50 characters" }),
  email: z
    .string()
    .min(1, { message: "Email is required" })
    .email({ message: "Please enter a valid email address" }),
  // Add more fields as needed
});

export type ExampleFormType = z.infer<typeof exampleFormSchema>;

export const defaultExampleForm: ExampleFormType = {
 name: "",
 email: ""
}
```

## 2. Action Layer

Implement server actions for form submission:

```ts
// apps/web/actions/feature/example-form.action.ts
'use server'

import { exampleFormSchema } from "@/schemas/example-form.schema";
import { revalidatePath } from "next/cache";

export type FormActionResult = {
  success: boolean;
  message?: string;
  fieldErrors?: Record<string, string[]>;
};

export async function submitExampleForm(
  prevState: FormActionResult, 
  formData: FormData
): Promise<FormActionResult> {
  // Extract data from FormData
  const rawFormData = Object.fromEntries(formData.entries());
  
  // Validate with Zod
  const validationResult = exampleFormSchema.safeParse(rawFormData);
  
  if (!validationResult.success) {
    return {
      success: false,
      fieldErrors: validationResult.error.flatten().fieldErrors,
      message: "Please correct the errors below"
    };
  }
  
  try {
    const validData = validationResult.data;
    
    // Add your logic here: database operations, API calls, etc.
    
    // Revalidate cache if needed
    revalidatePath('/path/to/page');
    
    return {
      success: true,
      message: "Form submitted successfully!"
    };
  } catch (error) {
    console.error("Form submission error:", error);
    return {
      success: false,
      message: "An error occurred while submitting the form."
    };
  }
}
```

## 3. UI Layer

Create form components using React Hook Form and shadcn/ui:

```tsx
// apps/web/components/feature-components/example-form.tsx
'use client'

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useFormState, useFormStatus } from "react-dom";
import { exampleFormSchema, ExampleFormType, defaultExampleForm } from "@/schemas/example-form.schema";
import { submitExampleForm } from "@/actions/feature/example-form.action";
import { useEffect } from "react";
import { useToast } from "@repo/design-system/components/ui/use-toast";

// Import shadcn UI components
import { Button } from "@repo/design-system/components/ui/button";
import { Input } from "@repo/design-system/components/ui/input";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@repo/design-system/components/ui/form";

const initialState = {
  success: false,
  message: "",
  fieldErrors: {},
};

export function ExampleForm() {
  const [state, formAction] = useFormState(submitExampleForm, initialState);
  const { toast } = useToast();
  
  // Set up React Hook Form with Zod resolver
  const form = useForm<ExampleFormType>({
    resolver: zodResolver(exampleFormSchema),
    defaultValues: defaultExampleForm
    mode: "onTouched",
  });
  
  // Handle server-side validation errors or success message
  useEffect(() => {
    // Handle field errors
    if (state.fieldErrors && Object.keys(state.fieldErrors).length > 0) {
      Object.entries(state.fieldErrors).forEach(([fieldName, errors]) => {
        if (errors && errors.length > 0) {
          form.setError(fieldName as any, {
            type: "server",
            message: errors[0],
          });
        }
      });
    }
    
    // Show success or error toast
    if (state.message) {
      toast({
        title: state.success ? "Success" : "Error",
        description: state.message,
        variant: state.success ? "default" : "destructive",
      });
      
      // Reset form on success
      if (state.success) {
        form.reset();
      }
    }
  }, [state, form, toast]);
  
  // Handle form submission
  const onSubmit = (data: ExampleFormValues) => {
    const formData = new FormData();
    
    // Add form fields to FormData
    Object.entries(data).forEach(([key, value]) => {
      formData.append(key, value);
    });
    
    // Submit using the server action
    formAction(formData);
  };
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input placeholder="Your name" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input placeholder="your.email@example.com" type="email" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <SubmitButton />
      </form>
    </Form>
  );
}

// Submit button with loading state
function SubmitButton() {
  const { pending } = useFormStatus();
  
  return (
    <Button type="submit" disabled={pending} className="w-full">
      {pending ? "Submitting..." : "Submit"}
    </Button>
  );
}
```

## 4. Integration in Pages

Add the form component to your page:

```tsx
// apps/web/app/feature/page.tsx
import { ExampleForm } from "@/components/feature-components/example-form";

export default function FeaturePage() {
  return (
    <div className="max-w-2xl mx-auto py-12 px-4">
      <div className="space-y-6">
        <div className="space-y-2">
          <h1 className="text-3xl font-bold">Example Form</h1>
          <p className="text-muted-foreground">
            Fill out the form below.
          </p>
        </div>
        
        <div className="border rounded-lg p-6 shadow-sm">
          <ExampleForm />
        </div>
      </div>
    </div>
  );
}
```

## 5. Best Practices

1. **File Naming**:
   - Schema files: `{form-name}.schema.ts`
   - Action files: `{form-name}.action.ts`
   - Form components: `{form-name}-form.tsx`

2. **Form State Management**:
   - Use `useFormState` and `useFormStatus` from React
   - Handle optimistic updates with `useOptimistic` for better UX
   
3. **Validation**:
   - Always validate on both client and server
   - Use Zod for type-safe validation
   - Custom error messages should be user-friendly

4. **Accessibility**:
   - Include proper labels for all form fields
   - Use aria attributes where appropriate
   - Ensure keyboard navigation works

5. **Performance**:
   - Optimize form submission with proper loading states
   - Only re-render what's necessary
   - Use `useTransition` for smoother user experience

6. **Error Handling**:
   - Provide clear error messages
   - Display both field-level and form-level errors
   - Implement proper error logging

7. **Security**:
   - Always validate data on the server
   - Use CSRF protection (built into Next.js)
   - Sanitize user inputs

8. **Reusability**:
   - Create reusable form components when possible
   - Extract common validation patterns

By following this architecture and these best practices, we ensure consistent, maintainable, and user-friendly forms throughout the application.
